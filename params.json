{"name":"ValueUtils","tagline":"ValueUtils efficiently implements `.Equals()` and `.GetHashCode()` for you.  ","body":"ValueUtils\r\n==========\r\n\r\nValueUtils implements `Equals` and `GetHashCode` for you.  By using runtime code-generation, the performance overhead is kept small; `ValueObject<>` generally outperforms alternatives such as `Tuple<>`, `struct` or anonymous types (see benchmarks below). \r\n\r\nThe library is available on nuget (for import or direct download) as [ValueUtils](https://www.nuget.org/packages/ValueUtils/).  Though it's implemented in C#, it's just as applicable to VB.NET classes.\r\n\r\n\r\nUsage:\r\n---\r\n\r\nThe easiest way to use value semantics is to derive from `ValueObject<>`, for example:\r\n\r\n```C#\r\nusing ValueUtils;\r\nsealed class MyValueObject : ValueObject<MyValueObject> {\r\n\tpublic int A, B, C;\r\n\tpublic string X,Y, Z;\r\n// ...\r\n}\r\n```\r\nA class deriving from `ValueObject<T>` implements `IEquatable<T>` and has `Equals(object)`, `Equals(T)`, `GetHashCode()` and the `==` and `!=` operators implemented in terms of their fields.\r\n\r\n\r\nYou can also generate delegates for hashing and equality comparison for any type (also types in other assemblies you don't control).  Given the following example class:\r\n```C#\r\nclass ExampleClass {\r\n\tpublic string myMember;\r\n\tprotected readonly DateTime supports_readonly_too;\r\n\tint private_int;\r\n// ...\r\n}\r\n```\r\n\r\nHash code usage is as follows:\r\n\r\n```C#\r\nusing ValueUtils;\r\n\r\nFunc<ExampleClass, int> hashfunc = FieldwiseHasher<ExampleClass>.Instance;\r\n//or call directly \r\nint hashcode = FieldwiseHasher.Hash(my_example_object);\r\n```\r\n\r\nEquality usage is as follows:\r\n```C#\r\nusing ValueUtils;\r\n\r\nFunc<ExampleClass, ExampleClass, bool> equalityComparer = FieldwiseEquality<ExampleClass>.Instance;\r\n//or call directly \r\nbool areEqual = FieldwiseEquality.AreEqual(my_example_object, another_example_object);\r\n```\r\n\r\nThe above delegates are considerably faster that the built-in `ValueType`-provided defaults for `struct`s (which use reflection every call), which is why they're a good fit to help implement `GetHashCode` and `Equals` for your own structs.\r\n\r\nLimitations and gotcha's\r\n----\r\n`ValueObject<>` supports self-referential types (like tree structures or a singly linked list), but does not support cyclical types - such as a doubly linked list.  Whenever a cycle is encountered, the hash function and equals operations will not terminate (until the stack overflows).\r\n\r\nEquality is implemented on a per-type basis, and that means inheritance gets confusing.  It's OK to *have* a base class (and base class fields will affect hash and equality), but if you use the base-class's equality and/or hash implementation on a subclass *instance* the code will seem to work but only consider the fields of the base class.  Best practice: don't create sub-classes that add new fields; and if you do then at least never use the base-class equality+hashcode implementations.  This is why ValueObject verifies that its subclasses must be sealed.\r\n\r\n`FieldwiseHasher` and `FieldwiseEquality` \"work\" on almost all types, including types with private members in other assemblies - however, if you don't know the internals, you can't be sure what's being included in the equality computations.  In particular, if an object is lazily initialized, two semantically equivalent objects might compute as unequal simply because one is initialized and the other is not.  In practice this is rarely a problem.\r\n\r\n\r\nPerformance and hash-quality\r\n----\r\n**TL;DR** `ValueObject<>` usually outperforms alternatives such as `Tuple<>`, `struct` and anonymous types.   Compared to hand-rolled implementations common operations such as `.ToDictionary` are around 15-25% slower (if your object contains \"expensive\" data such as large strings, the difference will become a lot smaller).\r\n\r\nAll performance measurements were done on an i7-4770k at a fixed clock rate of 4.0GHz.    Timings are in nanoseconds per object.  Datasets are all approximately 3000000 objects in size. Loops over the dataset were repeated until 10 seconds were up, then the fastest quartile average reported (this minimizes interference by other processes on my dev machine since random interference is almost always bad for performance, not good).  Some hash generators (notably `struct`) are so poor that this wasn't feasible, those timings are omitted (NaN) below.\r\n\r\nNote that even a perfect hash mix is expected to have 0.03-0.04% colliding buckets, so if you see numbers like that in the data below, a hash if functioning as expected.  Numbers better(lower) than that are actually worrisome, because that means some kind of structure in the input is being exploited, and that likely means similar but slightly different data exists that will have lots of collisions.  And of course, number much higher that that directly impact performance.\r\n\r\nQuite a few tests use a simple pair of ints - this is relevant because this is pretty much a worst case for ValueObject.   Although the generated code is fast, calling into that code requires a cast and a Delegate call, and those are (relatively) expensive operations in .NET - at least, compared to simple integer math that a pair-of-ints hashcode requires.  With more complicated objects containing reference types the cost of the hashcode computation will start to matter more, and the overhead less.\r\n\r\n<div>\r\n  <table>\r\n    <thead>\r\n      <tr>\r\n        <th colspan=\"7\">Realistic scenario with an enum, a string, a DateTime, an int? and 3 int fields.</th>\r\n      </tr>\r\n      <tr>\r\n        <th>Name</th>\r\n        <th>Collisions</th>\r\n        <th>Distinct Hashcodes</th>\r\n        <th>.ToDictionary()</th>\r\n        <th>.Distinct().Count()</th>\r\n        <th>.Equals()</th>\r\n        <th>.GetHashCode()</th>\r\n      </tr>\r\n    </thead>\r\n    <tbody>\r\n      <tr>\r\n        <td>ComplicatedManual</td>\r\n        <td>0.04%</td>\r\n        <td>2912961 / 2914000</td>\r\n        <td>218.8</td>\r\n        <td>199.6</td>\r\n        <td>6.9</td>\r\n        <td>17.4</td>\r\n      </tr>\r\n      <tr>\r\n        <td>ComplicatedValueObject</td>\r\n        <td>0.04%</td>\r\n        <td>2912977 / 2914000</td>\r\n        <td>250.2</td>\r\n        <td>230.5</td>\r\n        <td>21.4</td>\r\n        <td>42.1</td>\r\n      </tr>\r\n      <tr>\r\n        <td>Tuple</td>\r\n        <td>0.03%</td>\r\n        <td>2913001 / 2914000</td>\r\n        <td>482.2</td>\r\n        <td>494.8</td>\r\n        <td>257.6</td>\r\n        <td>263.5</td>\r\n      </tr>\r\n      <tr>\r\n        <td>ComplicatedStruct</td>\r\n        <td>100.00%</td>\r\n        <td>2 / 2914000</td>\r\n        <td>NaN</td>\r\n        <td>NaN</td>\r\n        <td>1002.3</td>\r\n        <td>97.2</td>\r\n      </tr>\r\n      <tr>\r\n        <td>Anonymous Type</td>\r\n        <td>0.03%</td>\r\n        <td>2913022 / 2914000</td>\r\n        <td>261.0</td>\r\n        <td>247.8</td>\r\n        <td>31.5</td>\r\n        <td>52.9</td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n  <table>\r\n    <thead>\r\n      <tr>\r\n        <th colspan=\"7\">A simple pair of ints</th>\r\n      </tr>\r\n      <tr>\r\n        <th>Name</th>\r\n        <th>Collisions</th>\r\n        <th>Distinct Hashcodes</th>\r\n        <th>.ToDictionary()</th>\r\n        <th>.Distinct().Count()</th>\r\n        <th>.Equals()</th>\r\n        <th>.GetHashCode()</th>\r\n      </tr>\r\n    </thead>\r\n    <tbody>\r\n      <tr>\r\n        <td>IntPairManual</td>\r\n        <td>0.02%</td>\r\n        <td>2975318 / 2976000</td>\r\n        <td>159.3</td>\r\n        <td>133.6</td>\r\n        <td>3.8</td>\r\n        <td>1.7</td>\r\n      </tr>\r\n      <tr>\r\n        <td>IntPairValueObject</td>\r\n        <td>0.03%</td>\r\n        <td>2974963 / 2976000</td>\r\n        <td>199.3</td>\r\n        <td>181.9</td>\r\n        <td>20.0</td>\r\n        <td>16.9</td>\r\n      </tr>\r\n      <tr>\r\n        <td>Tuple</td>\r\n        <td>38.31%</td>\r\n        <td>1835788 / 2976000</td>\r\n        <td>353.7</td>\r\n        <td>289.2</td>\r\n        <td>98.4</td>\r\n        <td>54.9</td>\r\n      </tr>\r\n      <tr>\r\n        <td>IntPairStruct</td>\r\n        <td>56.61%</td>\r\n        <td>1291168 / 2976000</td>\r\n        <td>864.7</td>\r\n        <td>812.6</td>\r\n        <td>31.4</td>\r\n        <td>36.8</td>\r\n      </tr>\r\n      <tr>\r\n        <td>Anonymous Type</td>\r\n        <td>4.69%</td>\r\n        <td>2836344 / 2976000</td>\r\n        <td>185.2</td>\r\n        <td>158.2</td>\r\n        <td>15.3</td>\r\n        <td>13.5</td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n  <table>\r\n    <thead>\r\n      <tr>\r\n        <th colspan=\"7\">Two ints with both the same value</th>\r\n      </tr>\r\n      <tr>\r\n        <th>Name</th>\r\n        <th>Collisions</th>\r\n        <th>Distinct Hashcodes</th>\r\n        <th>.ToDictionary()</th>\r\n        <th>.Distinct().Count()</th>\r\n        <th>.Equals()</th>\r\n        <th>.GetHashCode()</th>\r\n      </tr>\r\n    </thead>\r\n    <tbody>\r\n      <tr>\r\n        <td>IntPairManual</td>\r\n        <td>0.37%</td>\r\n        <td>2988915 / 3000000</td>\r\n        <td>188.5</td>\r\n        <td>155.6</td>\r\n        <td>3.6</td>\r\n        <td>1.7</td>\r\n      </tr>\r\n      <tr>\r\n        <td>IntPairValueObject</td>\r\n        <td>0.03%</td>\r\n        <td>2999012 / 3000000</td>\r\n        <td>200.8</td>\r\n        <td>194.6</td>\r\n        <td>19.7</td>\r\n        <td>16.5</td>\r\n      </tr>\r\n      <tr>\r\n        <td>Tuple</td>\r\n        <td>22.07%</td>\r\n        <td>2337827 / 3000000</td>\r\n        <td>145.2</td>\r\n        <td>140.5</td>\r\n        <td>76.4</td>\r\n        <td>55.1</td>\r\n      </tr>\r\n      <tr>\r\n        <td>IntPairStruct</td>\r\n        <td>100.00%</td>\r\n        <td>1 / 3000000</td>\r\n        <td>NaN</td>\r\n        <td>NaN</td>\r\n        <td>31.0</td>\r\n        <td>36.7</td>\r\n      </tr>\r\n      <tr>\r\n        <td>Anonymous Type</td>\r\n        <td>0.00%</td>\r\n        <td>3000000 / 3000000</td>\r\n        <td>144.5</td>\r\n        <td>106.3</td>\r\n        <td>12.1</td>\r\n        <td>13.5</td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n  <table>\r\n    <thead>\r\n      <tr>\r\n        <th colspan=\"7\">Two ints such that (x,y) is present iif (y,x) is present in the dataset</th>\r\n      </tr>\r\n      <tr>\r\n        <th>Name</th>\r\n        <th>Collisions</th>\r\n        <th>Distinct Hashcodes</th>\r\n        <th>.ToDictionary()</th>\r\n        <th>.Distinct().Count()</th>\r\n        <th>.Equals()</th>\r\n        <th>.GetHashCode()</th>\r\n      </tr>\r\n    </thead>\r\n    <tbody>\r\n      <tr>\r\n        <td>IntPairManual</td>\r\n        <td>0.62%</td>\r\n        <td>3014881 / 3033584</td>\r\n        <td>154.3</td>\r\n        <td>140.5</td>\r\n        <td>3.6</td>\r\n        <td>1.7</td>\r\n      </tr>\r\n      <tr>\r\n        <td>IntPairValueObject</td>\r\n        <td>0.03%</td>\r\n        <td>3032561 / 3033584</td>\r\n        <td>192.8</td>\r\n        <td>174.6</td>\r\n        <td>19.6</td>\r\n        <td>17.0</td>\r\n      </tr>\r\n      <tr>\r\n        <td>Tuple</td>\r\n        <td>41.47%</td>\r\n        <td>1775545 / 3033584</td>\r\n        <td>457.5</td>\r\n        <td>432.1</td>\r\n        <td>76.0</td>\r\n        <td>54.8</td>\r\n      </tr>\r\n      <tr>\r\n        <td>IntPairStruct</td>\r\n        <td>74.50%</td>\r\n        <td>773500 / 3033584</td>\r\n        <td>804.6</td>\r\n        <td>775.8</td>\r\n        <td>31.0</td>\r\n        <td>36.6</td>\r\n      </tr>\r\n      <tr>\r\n        <td>Anonymous Type</td>\r\n        <td>0.79%</td>\r\n        <td>3009536 / 3033584</td>\r\n        <td>175.2</td>\r\n        <td>161.2</td>\r\n        <td>12.1</td>\r\n        <td>13.5</td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n  <table>\r\n    <thead>\r\n      <tr>\r\n        <th colspan=\"7\">A reference to the type itself and two int fields.  The dataset contains exactly one level of nesting such that the outer object is (x,y) when the inner is (y,x).</th>\r\n      </tr>\r\n      <tr>\r\n        <th>Name</th>\r\n        <th>Collisions</th>\r\n        <th>Distinct Hashcodes</th>\r\n        <th>.ToDictionary()</th>\r\n        <th>.Distinct().Count()</th>\r\n        <th>.Equals()</th>\r\n        <th>.GetHashCode()</th>\r\n      </tr>\r\n    </thead>\r\n    <tbody>\r\n      <tr>\r\n        <td>NastyNestedManual</td>\r\n        <td>24.14%</td>\r\n        <td>2267216 / 2988648</td>\r\n        <td>225.1</td>\r\n        <td>181.5</td>\r\n        <td>6.3</td>\r\n        <td>5.0</td>\r\n      </tr>\r\n      <tr>\r\n        <td>NastyNestedValueObject</td>\r\n        <td>0.03%</td>\r\n        <td>2987634 / 2988648</td>\r\n        <td>239.7</td>\r\n        <td>208.8</td>\r\n        <td>30.9</td>\r\n        <td>33.0</td>\r\n      </tr>\r\n      <tr>\r\n        <td>Tuple</td>\r\n        <td>57.80%</td>\r\n        <td>1261193 / 2988648</td>\r\n        <td>489.5</td>\r\n        <td>491.8</td>\r\n        <td>103.3</td>\r\n        <td>132.0</td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n</div>","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}